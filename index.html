
<html>

<head>

	<meta http-equiv="Content-Type" content="text/html; charset=cp1251">

	<style type='text/css'>
		
		body { 
			background-color: #FAFCFF;
			font-family: sans-serif; 
			scroll-behavior: smooth;
			margin:0; padding:0;
		}
		
		.header {
			position:fixed; left:0; top:0; z-index:999; height:60px; width:100%; margin:0; padding:0; display:block;
			border-bottom:0px solid #06446D; background-color:#06446D;
		}
		.menu {
			height:60px; margin:0px 0px 0px 24px; padding:0px; text-align:left; display:table;
		}
		.menu div {
			height:100%; margin-left:4px; padding:0px 8px 0px 8px; display:table-cell; vertical-align:middle; 
			font-size:18px;
		}
		.menu div.normal { color:white; }
		.menu div.active { color:#EFC133; padding-top:4px; border-bottom:4px solid #EFC133; }
		.menu .logo {
			width:340px; height:60px; display:table-cell; margin:0px 24px 0px 24px; vertical-align:middle; color:white;
			background: 
				url(data:image/png;base64,XXXX)
				no-repeat left;
		}
		 
		.content {
			width:100%;
			position: absolute; top:60px; left:0px;
			border-top:0px solid white;
			margin:0; padding:0;
			background-color:#ffffff;
		}		

		.page {
			display:none;
			width:100%;
			margin:0; padding:0;
			background-color:#ffffff;
			padding-bottom:4%; 
		}


		div.table-row {
			display:table;
			margin:0; padding:0;			
		}
		
		div.table-row div {
			width:33vw; height:20vh; padding:2%; background-color:#ffffff; color:white; text-align:center; display:table-cell; vertical-align:middle;
			margin:0; padding:0;			
		}
		div.table-row div div {
			background-color:#2B6D9A; color:white; text-align:center; 
			margin:0; padding:0;			
		}

		ul {
			list-style-image:url(data:image/png;base64,XXXX);
		}
		ul li {
			margin:4%;
			font-size:140%;
		}
    	
    	h1 { margin:2% 1% 1% 4%; font-size:140%; color:#06446D; font-variant:small-caps; }

		.slidecontainer { width: 100%; }

		.slider { 
			-webkit-appearance: none;
			width: 100%; height: 5px; background: #d3d3d3; outline: none; opacity: 0.7;
    		-webkit-transition: .2s; transition: opacity .2s;
		}

		.slider:hover { opacity: 1; }

		.slider::-webkit-slider-thumb {
    		-webkit-appearance: none; appearance: none;
    		width: 25px; height: 5px; background: #4CAF50; cursor: pointer;
		}

		.slider::-moz-range-thumb {
    		width: 25px; height: 5px; background: #4CAF50; cursor: pointer;
		}    	

	</style>
	
	<script type='text/javascript'>
		
		var aPages;
		var aMenuIds;
		var sMenuActiveId="";
				
		window.onload = function() {
			aPages = document.querySelectorAll('[data-pageid]');
			for( var i = 0 ; i < aPages.length ; i++ ) {
				aPages[i].className='page';
			}
			
			aMenuIds = document.querySelectorAll('[data-menuid]');
			for( var i = 0 ; i < aMenuIds.length ; i++ ) {
				aMenuIds[i].style.cursor = 'pointer';
				aMenuIds[i].className = 'normal';
				aMenuIds[i].onclick = function() {
					menuGoTo( this.getAttribute("data-menuid") );
				}
			}

			menuGoTo( "main" );
		}	
		
		function menuGoTo( sId ) {		
			
			for( var i = 0 ; i < aPages.length ; i++ ) {
				sPageId = aPages[i].getAttribute("data-pageid");
				if( sPageId == sId ) {
					aPages[i].style.display = 'block';
				} else {
					aPages[i].style.display = 'none';
				}
			}
			menuHighlight( sId );			
		}
		
		function menuHighlight( sId ) {
			for( var i = 0 ; i < aMenuIds.length ; i++ ) {
				if( sId == aMenuIds[i].getAttribute( "data-menuid") ) {
					aMenuIds[i].className='active';
				} else {
					aMenuIds[i].className='normal';
				}
			}
			sMenuActiveId = sId;
		}
						
	</script>
	
</head>

<body>

<!-- Header -->
<div class='header'>
	<div class='menu'>
		<div class='logo'>
			<div style='background: -webkit-linear-gradient(#FFFFFF, #7F7F7F); -webkit-background-clip: text; -webkit-text-fill-color: transparent; font-style:italic;'>SPIDER PROJECT</div>
		</div>
		<div data-menuid='main'>&nbsp;&nbsp;&nbsp;&nbsp;GANTT CHART&nbsp;&nbsp;&nbsp;&nbsp;</div>
		<div data-menuid='help'>&nbsp;&nbsp;&nbsp;&nbsp;HELP&nbsp;&nbsp;&nbsp;&nbsp;</div>
	</div>
</div>

<div class='content'>
			<div data-pageid='main'>
				<div>DEBUG MESAGE: <span id='debug'></span> </div>
				<div id='containerDiv' style='width:98%; margin-left:1%; font-family:Courier New, Courier, monospace;'>
					<svg id='containerSVG' style='margin:0; padding:0;'>
						<svg id='timeSVG' preserveAspectRatio='none' style='margin:0; padding:0;'></svg>
						<svg id='ganttSVG' preserveAspectRatio='none' style='margin:0; padding:0;'></svg>
						<svg id='tableContentSVG' preserveAspectRatio='none' style='margin:0; padding:0;'></svg>
						<svg id='tableHeaderSVG' preserveAspectRatio='none' style='margin:0; padding:0;'></svg>
						<svg id='verticalSplitterSVG' preserveAspectRatio='none' style='margin:0; padding:0;'></svg>
						<svg id='tableScrollSVG' preserveAspectRatio='none' style='margin:0; padding:0;'></svg>
						<svg id='ganttScrollSVG' preserveAspectRatio='none' style='margin:0; padding:0;'></svg>
						<svg id='verticalScrollSVG' preserveAspectRatio='none' style='margin:0; padding:0;'></svg>
					</svg>
				</div>
			</div>
			<div data-pageid='help'>
				<h1>HELP</h1>
			</div>
</div>


<script type="text/javascript">

var NS = "http://www.w3.org/2000/svg";

var monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

var data = {
	factStartMin:-1, factFinMax:-1, asapStartMin:-1, asapFinMax:-1, startMin:-1, finMax:-1, startFin:-1,
	operations: [
		{ level:1, code:'1', name:'Phase 1', factStart:'01.01.2007  08:00', factFin:'15.01.2007  16:00', asapStart:'01.01.2007  08:00', asapFin:'15.01.2007  08:00', costTotal:100, volSum:1000, durSumD:24 },
		{ level:2, code:'2', name:'Phase 2', factStart:'07.01.2007  08:00', factFin:'17.01.2007  16:00', asapStart:'07.01.2007  08:00', asapFin:'17.01.2007  10:00', costTotal:100, volSum:1300, durSumD:20 },
		{ level:3, code:'3', name:'Phase 3', factStart:'09.01.2007  08:00', factFin:'15.01.2007  16:00', asapStart:'09.01.2007  08:00', asapFin:'15.01.2007  08:00', costTotal:100, volSum:1004, durSumD:23 },
		{ level:4, code:'4', name:'Phase 4', factStart:'15.01.2007  08:00', factFin:'12.02.2007  16:00', asapStart:'15.01.2007  08:00', asapFin:'12.02.2007  10:00', costTotal:100, volSum:1000, durSumD:23 },
		{ level:null, code:'5', name:'Oper 5', factStart:'15.01.2007  08:00', factFin:'20.01.2007  16:00', asapStart:'15.01.2007  08:00', asapFin:'20.01.2007  10:00', costTotal:100, volSum:3400, durSumD:10 },
		{ level:null, code:'6', name:'Oper 6', factStart:'20.01.2007  08:00', factFin:null, asapStart:'21.01.2007  08:00', asapFin:'23.01.2007  10:00', costTotal:100, volSum:1540, durSumD:20 },
		{ level:null, code:'7', name:'Oper 7', factStart:null, factFin:null, asapStart:'21.01.2007  08:00', asapFin:'12.02.2007  10:00', costTotal:100, volSum:1050, durSumD:21 }
	],
	operationsLinks: [
		{ predCode:'5', succCode:'6', typeSF:'FS', lagType:'time', lagUnit:'hour', lag:10 },
		{ predCode:'6', succCode:'7', typeSF:'FF', lagType:'time', lagUnit:'hour', lag:10 }
	],
	resourses: [
		{ level:0, code:'0', name:'Resourse #0', type:'Type #0', number:1 },
		{ level:1 , code:'1', name:'Resourse #1', type:'Type #1', number:10 },
		{ level:0 , code:'1.1', name:'Subresourse of #1', type:'Type #1.1', number:10 },
		{ level:0 , code:'1.1', name:'Subresourse of #1', type:'Type #1.2', number:10 }
	],
	assignments: [
		{ operCode:'1', resCode:'0', number:1, prior:10 },
		{ operCode:'2', resCode:'1', number:1, prior:10 }
	],
	cost: [
		{ code:'0', name:'Name of Cost0' }, { code:'1', name:'Name of Cost1' }, 
		{ code:'2', name:'Name of Cost2' }, { code:'3', name:'Name of Cost3' }
	],
	operCost: [
		{ operCode:'0', costCode:'0', fix:2 }, { operCode:'1', costCode:'1', fix:4 }, 
		{ operCode:'2', costCode:'2', fix:10 }, { operCode:'3', costCode:'3', fix:100 }
	]
};

var colors = {
	level1:'#f8edc9', level2:'#ccffcc', level3:'#e1e1ff', level4:'#dfffff', level5:'#e6e6ff',
	level6:'#e6e6ff', level7:'#e6e6ff', level8:'#e6e6ff', level9:'#e6e6ff', level10:'#e6e6ff',
	oper:'#ffffff'
};

var tableColumns = [ { name:'[]', ref:'', width:30 }, { name:'Level', ref:'level', width:40 }, 
	{ name:'Code', ref:'code', width:80 }, { name:'Start', ref:'start', width:80 }, { name:'Finish', ref:'fin', width:80 }, 
	{ name:'Cost', ref:'costTotal', width:80 }, { name:'Vol.', ref:'volSum', width:80 }, { name:'Dur.', ref:'durSumD', width:80 } ]; 

var containerDiv = null;
var containerSVG = null;
var timeSVG = null;
var ganttSGV = null;
var tableContentSVG = null;
var tableContentSVGContainer = null;
var tableHeaderSVG = null;
var verticalSplitterSVG = null;
var tableScrollSVG = null;
var ganttHScrollSVG = null;
var verticalScrollSVG = null;

var zoomFactor = 1.25;

var ganttFontColor = '#4f4f4f';
var timeScaleFontColor = '#4f4f4f';
var timeScaleFillColor = '#cfcfdf';
var timeScaleStrokeColor = '#afafaf';
var tableHeaderFontColor = '#4f4f4f';
var tableHeaderFillColor = '#cfcfdf';
var tableHeaderStrokeColor = '#4f4f4f';
var tableContentFontColor = '#4f4f4f'
var tableContentFillColor = '#ffffff';
var tableContentStrokeColor = '#4f4f4f';

var containerDivHeight, containerDivWidth;

var ganttSVGWidth;
var ganttSVGHeight;
var ganttVisibleLeft;
var ganttVisibleWidth;
var ganttVisibleTop;
var ganttVisibleHeight;
var ganttSVGBkgr = null;

var timeSVGWidth;
var timeSVGHeight;
var timeSVGBkgr=null;

var tableContentSVGWidth;
var tableContentSVGHeight;
var tableContentSVGBkgr=null;

var tableHeaderSVGWidth;
var tableHeaderSVGHeight;
var tableHeaderSVGBkgr=null;
var tableHeaderOverallWidth=0;

var tableVisibleLeft=0;

var timeCaptured=false;
var timeCapturedAtX;

var ganttCaptured=false;
var ganttCapturedAtY;

var verticalSplitterSVGWidth;
var verticalSplitterSVGHeight;
var verticalSplitterSVGBkgr=null;
var verticalSplitterCaptured=false;
var verticalSplitterCapturedAtX;
var verticalSplitterPosition = 0.25;

var tableSplitterCaptured = -1;
var tableSplitterCapturedAtX = -1;

var scrollThick = 3;
var scrollSliderSize = 10;
var scrollBkgrColor = '#afafaf';
var scrollRectColor = '#7f7f7f';
var scrollSliderColor = '#4f4f4f';
var scrollSliderActiveColor = '#000000';
var tableScrollSVGWidth, tableScrollSVGHeight;
var tableScrollCaptured = false;
var tableScrollCapturedAtX = -1;
var tableScrollXAtCapture = -1;
var tableScrollSVGSlider=null;
var tableScrollSVGBkgr=null;

var ganttHScrollSVGWidth, ganttHScrollSVGHeight;
var ganttHScrollCaptured = false;
var ganttHScrollCapturedAtX = -1;
var ganttHScrollXAtCapture = -1;
var ganttHScrollSVGSlider=null;
var ganttHScrollSVGBkgr=null;

var verticalScrollSVGWidth, verticalScrollSVGHeight;
var verticalScrollCaptured = false;
var verticalScrollCapturedAtY = -1;
var gverticalScrollYAtCapture = -1;
var verticalScrollSVGSlider=null;
var verticalScrollSVGBkgr=null;

var ganttScrollSVGWidth, ganttScrollSVGHeight;
var verticalScrollSVGWidth, verticalScrollSVGHeight;

window.addEventListener( 'mouseup', function(e) { 
	if( timeCaptured ) { timeCaptured = false; } 
	if( ganttCaptured ) { ganttCaptured = false; } 
	if( verticalSplitterCaptured ) { verticalSplitterCaptured = false; } 
	if( tableScrollCaptured ) { tableScrollCaptured = false; }
	if( ganttHScrollCaptured ) { ganttHScrollCaptured = false; }
	if( verticalScrollCaptured ) { verticalScrollCaptured = false; }
	
	if( tableSplitterCaptured >= 0 ) {
		let el = document.getElementById('tableSplitter'+tableSplitterCaptured);
		let newWidth = tableColumns[tableSplitterCaptured].width + e.x - tableSplitterCapturedAtX;
		if( newWidth < 4 ) {
			newWidth = 4;
		}
		tableColumns[tableSplitterCaptured].width = newWidth;
		tableSplitterCaptured = -1;
		drawTableContent();
		drawTableHeader();
	}
}, true );

window.addEventListener( 'mousemove', function(e) { 
	if( verticalSplitterCaptured ) {
		verticalSplitterPosition = (e.x - verticalSplitterCapturedAtX) / containerDivWidth + verticalSplitterPosition;
		verticalSplitterCapturedAtX = e.x;

		let oldGanttSVGWidth = ganttSVGWidth;
		initLayoutCoords();
		drawTableScroll();
		drawGanttHScroll();
		ganttVisibleWidth *= (ganttSVGWidth / oldGanttSVGWidth);
		return;
	}
	if( tableSplitterCaptured >= 0 ) {
		let el = document.getElementById('tableSplitter'+tableSplitterCaptured);
		el.setAttributeNS(null,'x',e.x);
		return;
	}
	if( tableScrollCaptured ) {
		let maxVisibleStart = (tableHeaderOverallWidth > tableHeaderSVGWidth) ? (tableHeaderOverallWidth - tableHeaderSVGWidth) : 0;
		let newSliderX = tableScrollXAtCapture + (e.x - tableScrollCapturedAtX);
		let maxSlider = tableScrollSVGWidth - tableScrollSVGSlider.getBBox().width;
		if( newSliderX < 0 ) {
			newSliderX = 0;
		} else if( newSliderX > maxSlider ) {
			newSliderX = maxSlider;
		}
		tableVisibleLeft = newSliderX * maxVisibleStart / maxSlider;
		tableScrollSVGSlider.setAttributeNS( null,'x', newSliderX );
		drawTableHeader();
		drawTableContent();
		return;
	}
	if( ganttHScrollCaptured ) {
		let newSliderX = ganttHScrollXAtCapture + (e.x - ganttHScrollCapturedAtX);
		let maxSlider = ganttHScrollSVGWidth - ganttHScrollSVGSlider.getBBox().width;
		if( newSliderX < 0 ) {
			newSliderX = 0;
		} else if( newSliderX > maxSlider ) {
			newSliderX = maxSlider;
		}
		ganttVisibleLeft = data.startMin + newSliderX * (data.displayMaxWidth - ganttVisibleWidth) / maxSlider;
		ganttHScrollSVGSlider.setAttributeNS( null,'x', newSliderX );
		drawGantt();
		drawTimeScale();
		return;
	}
	if( verticalScrollCaptured ) {
		let newSliderY = verticalScrollYAtCapture + (e.y - verticalScrollCapturedAtY);
		let maxSlider = verticalScrollSVGHeight - verticalScrollSVGSlider.getBBox().height;
		if( newSliderY < 0 ) {
			newSliderY = 0;
		} else if( newSliderY > maxSlider ) {
			newSliderY = maxSlider;
		}
		ganttVisibleTop = newSliderY * (data.operations.length - ganttVisibleHeight) / maxSlider;
		verticalScrollSVGSlider.setAttributeNS( null,'y', newSliderY );
		drawGantt();
		drawTableContent();
		return;
	}
} );

initGanttData();

let success = initLayout();
if( success ) {
	initLayoutCoords();
	createDefs();
	drawTableContent(true);
	drawTableHeader(true);
	drawGantt(true);
	drawTimeScale();
	drawTableScroll( true );
	drawGanttHScroll( true );
	drawVerticalScroll( true );
}


function initGanttData() {
	// Retrieving min. and max. dates
	var parsed;
	for( let i = 0 ; i < data.operations.length ; i++ ) {
		let d = data.operations[i];
		parsed = parseDate( data.operations[i].asapStart );
		if( parsed != null ) {
			data.asapStartMin = reassignBoundaryValue( data.asapStartMin, parsed.timeInSeconds, false );
			data.operations[i].asapStartInSeconds = parsed.timeInSeconds;
		}
		parsed = parseDate( data.operations[i].asapFin );
		if( parsed != null ) {
			data.asapFinMax = reassignBoundaryValue( data.asapFinMax, parsed.timeInSeconds, true );
			data.operations[i].asapFinInSeconds = parsed.timeInSeconds;
		}
		parsed = parseDate( data.operations[i].factStart );
		if( parsed != null ) {
			data.factStartMin = reassignBoundaryValue( data.factStartMin, parsed.timeInSeconds, false );
			data.operations[i].factStartInSeconds = parsed.timeInSeconds;
		}
		parsed = parseDate( data.operations[i].factFin );
		if( parsed != null ) {
			data.factFinMax = reassignBoundaryValue( data.factFinMax, parsed.timeInSeconds, true );
			data.operations[i].factFinInSeconds = parsed.timeInSeconds;
		}
		// Start and finish
		if( data.operations[i].factFin != null ) {
			d.status = 100; // finished
			d.displayStartInSeconds = d.factStartInSeconds; 
			d.displayFinInSeconds = d.factFinInSeconds; 
			d.start = d.factStart;
			d.fin = d.factFin;
		} else {
			if( d.factStart == null ) { // Hasn't been started yet
				d.status = 0; // not started 
				d.displayStartInSeconds = d.asapStartInSeconds; 
				d.displayFinInSeconds = d.asapFinInSeconds;
				d.start = d.asapStart;
				d.fin = d.asapFin;
			} else { // started but not finished
				let divisor = d.asapFinInSeconds - d.factStartInSeconds;
				if( divisor > 0 ) {
					d.status = parseInt( (d.asapStartInSeconds - d.factStartInSeconds) * 100 / divisor); 
				} else {
					d.status = 50;
				}
				d.displayStartInSeconds = d.factStartInSeconds; 
				d.displayFinInSeconds = d.asapFinInSeconds;
				d.start = d.factStart;
				d.fin = d.asapFin;				
			}
		}
	}
	data.startMin = (data.asapStartMin > data.factStartMin) ? data.factStartMin : data.asapStartMin;
	data.finMax = (data.asapFinMax > data.factFinMax) ? data.asapFinMax : data.factFinMax;
	data.startFin = data.finMax - data.startMin;
	data.displayMax = data.finMax + (data.finMax-data.startMin)/2.0;
	data.displayMaxWidth = data.displayMax - data.startMin;

	// Initializing the structure 
	for( let i = 0 ; i < data.operations.length ; i++ ) {
		data.operations[i].id = 'ganttRect' + i; // Id
		data.operations[i].parents = []; // Initializing "parents"
		for( let j = i-1 ; j >= 0 ; j-- ) {
			if( data.operations[j].level != null ) {
				let l = data.operations[i].parents.length;
				if( l == 0 ) {
					if( data.operations[i].level == null ) {
						data.operations[i].parents.push(j);
					} else if( data.operations[i].level > data.operations[j].level ) {
						data.operations[i].parents.push(j);						
					}
				} else {
					let lastPushedIndex = data.operations[i].parents[l-1];
					if( data.operations[lastPushedIndex].level > data.operations[j].level ) {
						data.operations[i].parents.push(j);						
					}
				} 
			} 
		}
		if( data.operations[i].level == null ) {
			data.operations[i].expanded = false;
			data.operations[i].visible = true;
		} else {
			data.operations[i].expanded = true;			
			data.operations[i].visible = true;
		}
	}	
}

function initLayout() {
	splitter = verticalSplitterPosition;

	let plusColor = "#44AA44";
	let minusColor = "#AA4444";
	let zeroColor = "#7f7f7f";
	let backgroundColor = "#f0fff0";

	containerDiv = document.getElementById("containerDiv");
	containerSVG = document.getElementById("containerSVG");
	tableHeaderSVG = document.getElementById('tableHeaderSVG');
	tableContentSVG = document.getElementById('tableContentSVG');
	ganttSVG = document.getElementById("ganttSVG");
	timeSVG = document.getElementById("timeSVG");
	verticalSplitterSVG = document.getElementById("verticalSplitterSVG");
	tableScrollSVG = document.getElementById("tableScrollSVG");
	ganttHScrollSVG = document.getElementById("ganttScrollSVG");
	verticalScrollSVG = document.getElementById("verticalScrollSVG");

	initLayoutCoords();

	containerDiv.addEventListener('selectstart', function() { event.preventDefault(); return false; } );
	containerDiv.addEventListener('selectend', function() { event.preventDefault(); return false; } );

	// Table Header
	tableHeaderSVG.style.cursor = "pointer";
	tableHeaderSVG.onmouseover = function(e) { if( tableHeaderSVGBkgr ) tableHeaderSVGBkgr.setAttributeNS( null, 'stroke-width', 2 ); };
	tableHeaderSVG.onmouseout = function(e) { if( tableHeaderSVGBkgr ) tableHeaderSVGBkgr.setAttributeNS( null, 'stroke-width', 1 ); };

	// Table Content
	tableContentSVG.style.cursor = "pointer";
	tableContentSVG.onmouseover = function(e) { if( tableContentSVGBkgr ) tableContentSVGBkgr.setAttributeNS( null, 'stroke-width', 2 ); };
	tableContentSVG.onmouseout = function(e) { if( tableContentSVGBkgr ) tableContentSVGBkgr.setAttributeNS( null, 'stroke-width', 1 ); };
	//addOnMouseWheel( tableContentSVG, zoomYByWheel );

	// Vertical splitter
	verticalSplitterSVGBkgr = createRect( 0, 0, verticalSplitterSVGWidth, verticalSplitterSVGHeight, 
			{ stroke:tableContentStrokeColor, strokeWidth:1,  fill:tableContentFillColor } ); 	// backgroud rect
	verticalSplitterSVG.setAttributeNS(null,'cursor','col-resize');	
	verticalSplitterSVG.appendChild( verticalSplitterSVGBkgr );			
	verticalSplitterSVG.onmousedown = function(e) { verticalSplitterCaptured=true; verticalSplitterCapturedAtX=e.x; };

	// Gantt chart
	ganttSVG.style.cursor = "pointer";
	ganttSVG.onmousedown = function(e) { ganttCaptured = true; ganttCapturedAtY = e.clientY; };
	ganttSVG.onmousemove = onGanttCapturedMouseMove;
	addOnMouseWheel( ganttSVG, zoomYByWheel );

	// Time scale
	timeSVG.style.cursor = "pointer";
	timeSVG.onmouseover = function(e) { if( timeSVGBkgr ) timeSVGBkgr.setAttributeNS( null, 'stroke-width', 2 ); };
	timeSVG.onmouseout = function(e) { if( timeSVGBkgr ) timeSVGBkgr.setAttributeNS( null, 'stroke-width', 1 ); };
	timeSVG.onmousedown = function(e) { timeCaptured = true; timeCapturedAtX = e.clientX; };
	timeSVG.onmousemove = onTimeCapturedMouseMove;
	addOnMouseWheel( timeSVG, zoomXByWheel );	

	zoomX(null, null);
	zoomY(null, null);

	return true;
}

function initLayoutCoords() {
	splitter = verticalSplitterPosition;

	containerDivHeight = window.innerHeight - getElementPosition(containerDiv).y-10;
	containerDiv.style.height = containerDivHeight;
	containerDivWidth = parseInt( getComputedStyle(containerDiv).width );
	containerDiv.style.width = containerDivWidth;

	containerSVG.setAttributeNS(null, 'x', 0 );
	containerSVG.setAttributeNS(null, 'y', 0 ); 
	containerSVG.setAttributeNS(null, 'width', containerDivWidth ); // window.innerWidth-1  );
	containerSVG.setAttributeNS(null, 'height', containerDivHeight ); 

	// Table Header
	tableHeaderSVG.setAttributeNS(null, 'x', 0 );
	tableHeaderSVG.setAttributeNS(null, 'y', 0 ); 
	tableHeaderSVGWidth = containerDivWidth * splitter;
	tableHeaderSVG.setAttributeNS(null, 'width', tableHeaderSVGWidth ); // window.innerWidth * 0.1 );
	tableHeaderSVGHeight = containerDivHeight * 0.1;
	tableHeaderSVG.setAttributeNS(null, 'height', tableHeaderSVGHeight ); 

	// Table Content
	tableContentSVG.setAttributeNS(null, 'x', 0 );
	tableContentSVG.setAttributeNS(null, 'y', tableHeaderSVGHeight ); 
	tableContentSVGWidth = tableHeaderSVGWidth;
	tableContentSVG.setAttributeNS(null, 'width', tableContentSVGWidth ); // window.innerWidth * 0.1 );
	tableContentSVGHeight = containerDivHeight - tableHeaderSVGHeight - scrollThick;
	tableContentSVG.setAttributeNS(null, 'height', tableContentSVGHeight ); 

	// Vertical Splitter
	verticalSplitterSVG.setAttributeNS(null, 'x', tableContentSVGWidth );
	verticalSplitterSVG.setAttributeNS(null, 'y', 0 ); 
	verticalSplitterSVGWidth = 3; //containerDivWidth * 0.005;
	verticalSplitterSVG.setAttributeNS(null, 'width', verticalSplitterSVGWidth ); // window.innerWidth * 0.9 );
	verticalSplitterSVGHeight = containerDivHeight - scrollThick;
	verticalSplitterSVG.setAttributeNS(null, 'height', containerDivHeight ); //window.innerHeight/2 ); 

	// Gantt chart
	ganttSVG.setAttributeNS(null, 'x', tableContentSVGWidth + verticalSplitterSVGWidth );
	ganttSVG.setAttributeNS(null, 'y', tableHeaderSVGHeight ); 
	ganttSVGWidth = containerDivWidth - (tableContentSVGWidth + verticalSplitterSVGWidth) - scrollThick;
	ganttSVG.setAttributeNS(null, 'width', ganttSVGWidth ); // window.innerWidth * 0.9 );
	ganttSVGHeight = tableContentSVGHeight;
	ganttSVG.setAttributeNS(null, 'height', ganttSVGHeight ); //window.innerHeight/2 );

	// Time scale
	timeSVG.setAttributeNS(null, 'x', tableContentSVGWidth + verticalSplitterSVGWidth );
	timeSVG.setAttributeNS(null, 'y', 0 ); 
	timeSVGWidth = ganttSVGWidth;
	timeSVG.setAttributeNS(null, 'width', timeSVGWidth ); // window.innerWidth * 0.9 );
	timeSVGHeight = tableHeaderSVGHeight;
	timeSVG.setAttributeNS(null, 'height', timeSVGHeight ); //window.innerHeight/2 );

	// Table scrolling tool
	tableScrollSVG.setAttributeNS(null, 'x', 0 )
	tableScrollSVG.setAttributeNS(null, 'y', tableHeaderSVGHeight + tableContentSVGHeight ); 
	tableScrollSVGWidth = tableHeaderSVGWidth;
	tableScrollSVG.setAttributeNS(null, 'width', tableContentSVGWidth ); // window.innerWidth * 0.1 );
	tableScrollSVGHeight = scrollThick;
	tableScrollSVG.setAttributeNS(null, 'height', tableContentSVGHeight ); 

	// Gantt horizontal scrolling tool
	ganttHScrollSVG.setAttributeNS(null, 'x', tableContentSVGWidth + verticalSplitterSVGWidth )
	ganttHScrollSVG.setAttributeNS(null, 'y', tableHeaderSVGHeight + tableContentSVGHeight ); 
	ganttHScrollSVGWidth = ganttSVGWidth;
	ganttHScrollSVG.setAttributeNS(null, 'width', ganttHScrollSVGWidth );
	ganttHScrollSVGHeight = scrollThick;
	ganttHScrollSVG.setAttributeNS(null, 'height', ganttHScrollSVGHeight ); 

	// Vertical scrolling tool
	verticalScrollSVG.setAttributeNS(null, 'x', tableContentSVGWidth + verticalSplitterSVGWidth + ganttSVGWidth )
	verticalScrollSVG.setAttributeNS(null, 'y', 0 ); 
	verticalScrollSVGWidth = scrollThick;
	verticalScrollSVG.setAttributeNS(null, 'width', verticalScrollSVGWidth );
	verticalScrollSVGHeight = containerDivHeight;
	verticalScrollSVG.setAttributeNS(null, 'height', verticalScrollSVGHeight ); 
}

function findResoursesForOperation( operationIndex ) {
	let operationCode = data.operations[operationIndex].code;
	for( let i = 0 ; i < data.assignments.length ; i++ ) {
		if( data.assignments[i].operCode == operationCode ) {
			let resourseCode = data.assignments[i].resCode;
			for( let j = 0 ; j < data.resourses.length ; j++ ) {
				if( data.resourses[j].code == resourseCode ) {
					return { code:data.resourses[j].code, name:data.resourses[j].name, number:data.resourses[j].number }
				}
			}
		}
	}
	return null;
}

function calcVisibleOperations() {
	let numVisible = 0;
	for( let i = 0 ; i < data.operations.length ; i++ ) {
		if( data.operations[i].visible ) {
			numVisible += 1;
		}
	}
	return numVisible;
}


function drawGantt( init ) {
	if( !init ) {
		init = false;
	}
	if( init ) {
		while (ganttSVG.hasChildNodes()) {
			ganttSVG.removeChild(ganttSVG.lastChild);
		}		
		ganttSVGBkgr = createRect( 0, 0, ganttSVGWidth, ganttSVGHeight, {fill:'url(#ganttGradient)'} );
		ganttSVG.appendChild(ganttSVGBkgr);		
	} else {
		ganttSVGBkgr.setAttributeNS(null,'width',ganttSVGWidth);
	}

	let rectCounter = 0;
	for( let i = 0 ; i < data.operations.length ; i++ ) {
		let rect, text;

		if( init ) { // Initializing...
			let g = document.createElementNS( NS, 'g' ); // Container
			let properties = { fill:'#7f7fff', stroke:'#7f7fff', strokeWidth:1 };
			properties.opacity = (data.operations[i].level === null ) ? 0.75 : 1.0;
			properties.id = 'ganttRect'+i;
			rect = createRect( 0, 0, 1, 1, properties ); // Rectangle
			rect.onmouseover = function(e) { rect.setAttributeNS( null, 'stroke', '#4f4f7f' ); };
			rect.onmouseout = function(e) { rect.setAttributeNS( null, 'stroke', '#4f4f7f' ); };
			rect.style.cursor = 'pointer';
			g.appendChild(rect);

			let title = document.createElementNS( NS,'title' ); // Title
			title.textContent = "Operation: " + data.operations[i].name + "\r\n";
			if( data.operations[i].status == 0 ) {
				title.textContent += "Status: not started" + "\r\n";
			} else if( data.operations[i].status < 100 ) {
				title.textContent += "Status: " + data.operations[i].status + "% done" + "\r\n";
			} else {
				title.textContent += "Status: done" + "\r\n";				
			}
			let res = findResoursesForOperation( i );
			if( res != null ) {
				title.textContent += "Resourse: " + res.name + "\r\n";
			}
			for( let col=1 ; col < tableColumns.length ; col++ ) {
				let ref = tableColumns[col].ref;
				let content = data.operations[i][ref];
				if( content === 'undefined' || content == null ) {
					content = '-';
				}
				title.textContent += tableColumns[col].name + ": " + content + "\r\n";
			}
			g.appendChild(title);

			text = createText( data.operations[i].name, 0, 0, { fontSize:10, fill:ganttFontColor, id:'ganttText'+i } );
			text.style.cursor = 'pointer';
			g.appendChild(text);

			ganttSVG.appendChild(g);			
		} else {
			rect = document.getElementById( 'ganttRect'+i );
			text = document.getElementById( 'ganttText'+i );
		}
		if( !data.operations[i].visible ) {
			rect.setAttributeNS(null,'display','none');
			text.setAttributeNS(null,'display','none');
			continue;
		} 

		let rectStart = timeToScreen( data.operations[rectCounter].displayStartInSeconds );
		let rectEnd = timeToScreen( data.operations[rectCounter].displayFinInSeconds );
		let rectTop = operToScreen(rectCounter+0.2);
		let rectBottom = operToScreen(rectCounter+1.0-0.2);
		let rectVMiddle = rectTop + (rectBottom-rectTop)/2;
		rectCounter += 1;

		rect.setAttributeNS(null,'x',rectStart);
		rect.setAttributeNS(null,'width',rectEnd - rectStart);
		rect.setAttributeNS(null,'y',rectTop);
		rect.setAttributeNS(null,'height',rectBottom - rectTop);
		text.setAttributeNS(null,'x',rectEnd+10);
		text.setAttributeNS(null,'y',rectVMiddle);

		data.operations[i].left = rectStart;
		data.operations[i].right = rectEnd;
		data.operations[i].top = rectTop;
		data.operations[i].bottom = rectBottom;

		rect.setAttributeNS(null,'display','block');
		text.setAttributeNS(null,'display','block');
	}

	// Gantt links
	let lineProperties = { stroke:'#000000', strokeWidth:1 , strokeDasharray:'1,4,1,4', endingArrow:true };
	for( let i = 0 ; i < data.operationsLinks.length ; i++ ) {

		let predCode = data.operationsLinks[i].predCode;
		let succCode = data.operationsLinks[i].succCode;
		let predOp = null;
		let succOp = null;
		for( let op = 0 ; op < data.operations.length ; op++ ) {
			if( !predOp ) { 
				if( data.operations[op].code == predCode ) { predOp = op; }
			}
			if( !succOp ) {
				if( data.operations[op].code == succCode ) { succOp = op; }
			}
			if( predOp && succOp ) {
				break;
			}
		}

		if( predOp && succOp ) {
			let line, lineX1, lineY1, lineX2, lineY2;
			if( data.operationsLinks[i].typeSF == 'SS' || data.operationsLinks[i].typeSF == 'SF' ) {
				lineX1 = data.operations[predOp].left;
			} else {
				lineX1 = data.operations[predOp].right;				
			}
			lineY1 = data.operations[predOp].top + (data.operations[predOp].bottom - data.operations[predOp].top) / 2.0;
			if( data.operationsLinks[i].typeSF == 'SF' || data.operationsLinks[i].typeSF == 'FF' ) {
				lineX2 = data.operations[succOp].left;
			} else {
				lineX2 = data.operations[succOp].right;				
			}
			//lineX2 = (lineX2 > lineX1) ? lineX2-10 : lineX2+10;
			lineY2 = data.operations[succOp].top + (data.operations[succOp].bottom - data.operations[succOp].top) / 2.0;
			if( init ) {
				lineProperties.id='ganttLine'+i;
				line = createLine( lineX1, lineY1, lineX2, lineY2, lineProperties );
				ganttSVG.appendChild(line);				
			} else {
				line = document.getElementById( 'ganttLine'+i );
				line.setAttributeNS(null,'x1',lineX1);
				line.setAttributeNS(null,'x2',lineX2);
				line.setAttributeNS(null,'y1',lineY1);
				line.setAttributeNS(null,'y2',lineY2);
			}
			if( !data.operations[predOp].visible || !data.operations[succOp].visible ) {
				line.setAttributeNS(null,'display','none');
			} else {
				line.setAttributeNS(null,'display','block');				
			}
		}
	}	
}


function drawTableHeader( init ) {
	if( !init ) {
		var init = false;
	}
	if( init ) {
		while (tableHeaderSVG.hasChildNodes()) {
			tableHeaderSVG.removeChild(tableHeaderSVG.lastChild);
		}

		tableHeaderSVGBkgr = createRect( 0, 0, containerDivWidth, tableHeaderSVGHeight, 
			{ fill:'url(#timeScaleGradient)' } ); // backgroud rect
		tableHeaderSVG.appendChild( tableHeaderSVGBkgr );			

		let left = 0;
		for( let i = 0 ; i < tableColumns.length ; i++ ) {
			let rect = createSVG(left+1-tableVisibleLeft, 0, tableColumns[i].width-2, tableHeaderSVGHeight, 
				{ id:'tableHeaderColumnNameSVG'+i, 'fill':tableHeaderFillColor } );
			tableHeaderSVG.appendChild( rect );
			let text = createText( tableColumns[i].name, tableColumns[i].width/2, tableHeaderSVGHeight/2, 
				{ alignmentBaseline:'baseline', textAnchor:'middle' , fontSize:12, fill:tableHeaderFontColor } );
			rect.appendChild( text );
			left += tableColumns[i].width;
		}
		tableHeaderOverallWidth = left;
	} else {
		tableHeaderSVGBkgr.setAttributeNS(null,'x',-tableVisibleLeft);
		let left = 0;
		for( let i = 0 ; i < tableColumns.length ; i++ ) {
			let rect = document.getElementById('tableHeaderColumnNameSVG'+i);
			rect.setAttributeNS(null,'x',left+1-tableVisibleLeft);
			rect.setAttributeNS(null,'width',tableColumns[i].width-2);			
			left += tableColumns[i].width;
		}
		tableHeaderOverallWidth = left;		
	}
}


function drawTableContent( init ) {
	if( !init ) {
		init = false;
	}
	if( init ) {
		while (tableContentSVG.hasChildNodes()) {
			tableContentSVG.removeChild(tableContentSVG.lastChild);
		}

		let height = operToScreen(data.operations.length);
		tableContentSVGBkgr = createRect( 0-tableVisibleLeft, 0, containerDivWidth, height, 
			{ stroke:'none', strokeWidth:1,  fill:tableContentFillColor } ); 	// backgroud rect
		tableContentSVG.appendChild( tableContentSVGBkgr );		
		
		let left = 0;
		for( let col = 0 ; col < tableColumns.length ; col++ ) {
			let rect = createSVG( left+2-tableVisibleLeft, 0, tableColumns[col].width-4, height, 
				{ id:('tableColumnSVG'+col), fill: tableContentStrokeColor } );
			tableContentSVG.appendChild( rect );
			left += tableColumns[col].width;
		}

		for( let col = 0, left=0 ; col < tableColumns.length ; col++  ) { // Creating splitters
			left += tableColumns[col].width;
			let splitter = createRect( left-tableVisibleLeft, 0, 1, operToScreen(data.operations.length), {id:'tableSplitter'+col, fill:'#dfdfdf'} );
			splitter._columnNumber = col;
			splitter.setAttributeNS(null,'cursor','col-resize');
			tableContentSVG.appendChild(splitter);
			splitter.onmousedown = function(e) { tableSplitterCaptured=this._columnNumber; tableSplitterCapturedAtX=e.x; };
		}
	} else {
		tableContentSVGBkgr.setAttributeNS(null,'x',-tableVisibleLeft);
		let left = 0;
		for( let col = 0 ; col < tableColumns.length ; col++ ) {
			let rect = document.getElementById('tableColumnSVG'+col);
			rect.setAttributeNS(null,'x',left+2-tableVisibleLeft);
			rect.setAttributeNS(null,'width',tableColumns[col].width-4);
			left += tableColumns[col].width;			
			let splitter = document.getElementById('tableSplitter'+col); 
			splitter.setAttributeNS(null,'x',left-tableVisibleLeft);
		}
	}

	// Operations table
	let rectCounter = 0;
	for( let i = 0 ; i < data.operations.length ; i++ ) {
		let lineTop = operToScreen(rectCounter);
		let lineBottom = operToScreen(rectCounter+1.0);
		let lineHeight = lineBottom - lineTop;
		let lineMiddle = lineTop + lineHeight/2;
		let lineId = 'ganttTableLine' + i;

		let expand='[]';
		if( data.operations[i].level != null ) {
			if( data.operations[i].expanded ) {
				expand='[-]';
			} else {
				expand='[+]';				
			}
		}
		let expandText;
		let expandTextId = 'tableColumn0Row' + i;

		if( init ) {			
			expandText = createText( expand, tableColumns[0].width/2.0, lineMiddle, 
				{ id:expandTextId, fontSize:12, textAnchor:'middle', alignmentBaseline:'baseline' } );
	 		document.getElementById('tableColumnSVG0').appendChild(expandText);
	 		expandText._operationNumber=i;
	 		if( data.operations[i].level != null ) {
		 		expandText.onmousedown = function(e) {
		 			if( data.operations[this._operationNumber].expanded == true ) {
		 				for( let i = 0 ; i < data.operations.length ; i++ ) {
		 					for( let j = 0 ; j < data.operations[i].parents.length ; j++ ) {
		 	 					if( data.operations[i].parents[j] == this._operationNumber ) {
			 						data.operations[i].visible = false;
			 						break;
			 					}
			 				}
			 			}
		 				data.operations[this._operationNumber].expanded = false;
		 			} else {
		 				for( let i = 0 ; i < data.operations.length ; i++ ) {
		 					for( let j = 0 ; j < data.operations[i].parents.length ; j++ ) {
		 	 					if( data.operations[i].parents[j] == this._operationNumber ) {
			 						data.operations[i].visible = true;
			 						break;
			 					}
			 				}
			 			}
		 				data.operations[this._operationNumber].expanded = true;
		 			}
		 			drawGantt();
		 			drawTimeScale();
		 			drawTableContent();
		 		};
		 	}

			let left = tableColumns[0].width;
			for( let col = 1 ; col < tableColumns.length ; col++ ) {
				let ref = tableColumns[col].ref;
				let content = data.operations[i][ref];
				if( content === 'undefined' || content == null ) {
					content = '-';
				}

				let text = createText(content, tableColumns[col].width/2, lineMiddle, 
					{ id:('tableColumn'+col+'Row'+i), fill:tableContentStrokeColor, textAnchor:'middle', fontSize:10 } );
				document.getElementById('tableColumnSVG'+col).appendChild( text );
			}

		} else {
			expandText = document.getElementById(expandTextId);
			expandText.setAttributeNS(null,'x',tableColumns[0].width/2.0);
			expandText.setAttributeNS(null,'y',lineMiddle);
			expandText.firstChild.nodeValue = expand;

			let left = tableColumns[0].width;
			for( let col = 1 ; col < tableColumns.length ; col++ ) {
				let id = 'tableColumn'+col+'Row'+i;
				let el = document.getElementById(id);
				el.setAttributeNS(null,'x',tableColumns[col].width/2.0);
				el.setAttributeNS(null,'y',lineMiddle);
			}
		}

		//alert(document.getElementById('tableColumn0Row'+i).style.display);

		if( data.operations[i].visible /*&& document.getElementById(expandTextId).style.visibility == 'hidden'*/ ) {
			for( let col = 0 ; col < tableColumns.length ; col++ ) {
				let id = 'tableColumn'+col+'Row'+i;
				let el = document.getElementById(id);
				el.setAttributeNS(null,'display','block');
			}
		} else if( !data.operations[i].visible /*&& document.getElementById(expandTextId).style.visibility != 'hidden'*/ ) {
			for( let col = 0 ; col < tableColumns.length ; col++ ) {
				let id = 'tableColumn'+col+'Row'+i;
				let el = document.getElementById(id);
				el.setAttributeNS(null,'display','none');
			}
		}		
		if( data.operations[i].visible ) {
			rectCounter += 1;
		}				
	}
}


function drawTimeScale() {

	while (timeSVG.hasChildNodes()) {
		timeSVG.removeChild(timeSVG.lastChild);
	}
	timeSVGBkgr = createRect( 0, 0, timeSVGWidth, timeSVGHeight, { fill:'url(#timeScaleGradient)' } ); 	// backgroud rect
	timeSVG.appendChild( timeSVGBkgr );			

	let daysInScreen = (ganttVisibleWidth)/ (60*60*24);
	let dayRectWidth = timeSVGWidth / daysInScreen;

	let minTime = data.startMin * 1000; // screenToTime(0) * 1000;
	let maxTime = data.displayMax * 1000; // screenToTime( timeSVGWidth ) * 1000;
	let minDT = new Date(minTime);
	let maxDT = new Date(maxTime);
	let deltaY = maxDT.getFullYear() - minDT.getFullYear();
	let deltaM = maxDT.getMonth() - minDT.getMonth();
	let deltaD = maxDT.getDate() - minDT.getDate();
	let minY = minDT.getFullYear();
	let maxY = maxDT.getFullYear();
	let properties = { fill:'none', stroke:timeScaleStrokeColor, strokeWidth:0.25 };
	let textLength = (dayRectWidth > timeSVGHeight * 0.25) ? timeSVGHeight*0.25 : dayRectWidth * 0.75;
	let monthProperties = { fontSize:12, fill:timeScaleFontColor, textAnchor:'middle', alignmentBaseline:'baseline', lengthAdjust:"spacing" };
	let fontSize = (dayRectWidth > timeSVGHeight*0.25) ? timeSVGHeight*0.25 : dayRectWidth * 0.75;
	let dayProperties = { fontSize:fontSize, fill:timeScaleFontColor, textAnchor:'middle', alignmentBaseline:'baseline', textLength:textLength, lengthAdjust:"spacing" };
	let monthY = timeSVGHeight/3;
	let dayY = 2*timeSVGHeight/3;
	for( let y = minY ; y <= maxY ; y++ ) {
		let minM = ( y == minY ) ? minDT.getMonth() : 0;
		let maxM = ( y == maxY ) ? maxDT.getMonth() : 11;
		for( let m = minM ; m <= maxM ; m++ ) {
			let startOfMonth = new Date(y,m,1,0,0,0,0);
			let startOfMonthInSeconds = startOfMonth.getTime() / 1000;
			let endOfMonth = new Date(y,m+1,0,23,59,59,999);
			let endOfMonthInSeconds = endOfMonth.getTime() / 1000;
			let monthStartX = timeToScreen(startOfMonthInSeconds);
			let monthEndX = timeToScreen(endOfMonthInSeconds);
			let monthRect = createRect( monthStartX, monthY, monthEndX - monthStartX, timeSVGHeight/3, properties );		
			timeSVG.appendChild(monthRect);
			let monthText = createText( monthNames[m], monthStartX + (monthEndX - monthStartX)/2, monthY+timeSVGHeight/3-3, monthProperties );
			timeSVG.appendChild(monthText);

			//let minD = ( m == minM && y == minY ) ? minDT.getDate() : 1;
			//let maxD = ( m == maxM && y == maxY ) ? maxDT.getDate() : endOfMonth.getDate();
			let minD = 1;
			let maxD = endOfMonth.getDate();
			for( let d = minD ; d <= maxD ; d++ ) {
				let currentDay = new Date(y,m,d,0,0,0,0);
				let currentTimeInSeconds = currentDay.getTime()/1000;
				let dayStartX = timeToScreen(currentTimeInSeconds);
				let dayEndX = timeToScreen(currentTimeInSeconds + 60*60*24);
				let dayRect = createRect( dayStartX, dayY, dayEndX - dayStartX, timeSVGHeight/3, properties );		
				timeSVG.appendChild(dayRect);
				let dayText = createText( d.toString(), dayStartX + (dayEndX - dayStartX)/2, dayY+timeSVGHeight/3-3, dayProperties );
				timeSVG.appendChild(dayText);
			}
		}
	}
}

function drawTableScroll( init ) {
	if( !init ) {
		init = false;
	}
	let maxVisibleStart = (tableHeaderOverallWidth > tableScrollSVGWidth) ? (tableHeaderOverallWidth - tableScrollSVGWidth) : 0;
	let sliderSize = (maxVisibleStart > 0) ? (tableScrollSVGWidth*tableScrollSVGWidth/tableHeaderOverallWidth) : tableScrollSVGWidth;
	if( sliderSize < scrollSliderSize ) {
		sliderSize = scrollSliderSize;
	}

	if( init ) {
		let bbox = tableScrollSVG.getBBox();
		tableScrollSVGBkgr = createRect( 0, 0, tableScrollSVGWidth, tableScrollSVGHeight, 
			{ id:('tableScrollSVGBkgr'), fill:scrollBkgrColor, stroke:scrollRectColor, strokeWidth:1 } );
		tableScrollSVGSlider = createRect( 0, 0, sliderSize, tableScrollSVGHeight, 
			{ id:('tableScrollSVGSlider'), fill:scrollSliderColor } );
		//tableScrollSVGBkgr.setAttributeNS(null,'cursor','pointer');
		tableScrollSVGSlider.setAttributeNS(null,'cursor','pointer');
		tableScrollSVG.appendChild( tableScrollSVGBkgr );
		tableScrollSVG.appendChild( tableScrollSVGSlider );
		tableScrollSVGSlider.onmouseover = function(e) { this.setAttributeNS(null,'fill',scrollSliderActiveColor) };
		tableScrollSVGSlider.onmouseout = function(e) { this.setAttributeNS(null,'fill',scrollSliderColor) };
		tableScrollSVGSlider.onmousedown = function(e) {
			tableScrollCaptured = true;
			tableScrollCapturedAtX = e.x;
			tableScrollXAtCapture = this.getBBox().x;
		}
	} else {
		tableScrollSVGBkgr.setAttributeNS(null,'width',tableScrollSVGWidth);
		tableScrollSVGSlider.setAttributeNS(null,'width',sliderSize);
	}
}

function drawGanttHScroll( init ) {
	if( !init ) {
		init = false;
	}
	let overallWidth = data.displayMaxWidth;
	let maxVisibleLeft = (overallWidth > ganttVisibleWidth) ? (data.startMin + overallWidth - ganttVisibleWidth) : data.startMin;
	let sliderSize = (maxVisibleLeft > data.startMin) ? (ganttHScrollSVGWidth*ganttVisibleWidth/overallWidth) : ganttHScrollSVGWidth;
	if( sliderSize < scrollSliderSize ) {
		sliderSize = scrollSliderSize;
	}
	if( init ) {
		let bbox = ganttHScrollSVG.getBBox();
		ganttHScrollSVGBkgr = createRect( 0, 0, ganttHScrollSVGWidth, ganttHScrollSVGHeight, 
			{ id:('ganttHScrollSVGBkgr'), fill:scrollBkgrColor, stroke:scrollRectColor, strokeWidth:1 } );
		ganttHScrollSVGSlider = createRect( 0, 0, sliderSize, ganttHScrollSVGHeight, 
			{ id:('ganttHScrollSVGSlider'), fill:scrollSliderColor } );
		ganttHScrollSVGSlider.setAttributeNS(null,'cursor','pointer');
		ganttHScrollSVG.appendChild( ganttHScrollSVGBkgr );
		ganttHScrollSVG.appendChild( ganttHScrollSVGSlider );
		ganttHScrollSVGSlider.onmouseover = function(e) { this.setAttributeNS(null,'fill',scrollSliderActiveColor) };
		ganttHScrollSVGSlider.onmouseout = function(e) { this.setAttributeNS(null,'fill',scrollSliderColor) };
		ganttHScrollSVGSlider.onmousedown = function(e) {
			ganttHScrollCaptured = true;
			ganttHScrollCapturedAtX = e.x;
			ganttHScrollXAtCapture = this.getBBox().x;
		}
	} else {
		ganttHScrollSVGBkgr.setAttributeNS(null,'width',ganttHScrollSVGWidth);
		ganttHScrollSVGSlider.setAttributeNS(null,'width',sliderSize);
		let sliderPosition=0;
		if( maxVisibleLeft > data.startMin ) {
			sliderPosition = (ganttVisibleLeft-data.startMin) * (ganttHScrollSVGWidth-sliderSize) / (maxVisibleLeft-data.startMin);
		}
		ganttHScrollSVGSlider.setAttributeNS(null,'x',sliderPosition);
	}
}


function drawVerticalScroll( init ) {
	if( !init ) {
		init = false;
	}
	let overallHeight = data.operations.length;
	let maxVisibleTop = (overallHeight > ganttVisibleHeight) ? (overallHeight - ganttVisibleHeight) : 0;
	let sliderSize = (maxVisibleTop > 0) ? (verticalScrollSVGHeight*ganttVisibleHeight/overallHeight) : verticalScrollSVGHeight;
	if( sliderSize < scrollSliderSize ) {
		sliderSize = scrollSliderSize;
	}
	if( init ) {
		let bbox = verticalScrollSVG.getBBox();
		verticalScrollSVGBkgr = createRect( 0, 0, verticalScrollSVGWidth, verticalScrollSVGHeight, 
			{ id:('verticalScrollSVGBkgr'), fill:scrollBkgrColor, stroke:scrollRectColor, strokeWidth:1 } );
		verticalScrollSVGSlider = createRect( 0, 0, verticalScrollSVGWidth, sliderSize, 
			{ id:('verticalScrollSVGSlider'), fill:scrollSliderColor } );
		verticalScrollSVGSlider.setAttributeNS(null,'cursor','pointer');
		verticalScrollSVG.appendChild( verticalScrollSVGBkgr );
		verticalScrollSVG.appendChild( verticalScrollSVGSlider );
		verticalScrollSVGSlider.onmouseover = function(e) { this.setAttributeNS(null,'fill',scrollSliderActiveColor) };
		verticalScrollSVGSlider.onmouseout = function(e) { this.setAttributeNS(null,'fill',scrollSliderColor) };
		verticalScrollSVGSlider.onmousedown = function(e) {
			verticalScrollCaptured = true;
			verticalScrollCapturedAtY = e.y;
			verticalScrollYAtCapture = this.getBBox().y;
		}
	} else {
		verticalScrollSVGSlider.setAttributeNS(null,'height',sliderSize);
		let sliderPosition = 0;
		if( maxVisibleTop > 0 ) {
			sliderPosition = ganttVisibleTop * (verticalScrollSVGHeight-sliderSize) / maxVisibleTop;
		}
		verticalScrollSVGSlider.setAttributeNS(null,'y',sliderPosition);
	}
}


function zoomX( zoomFactorChange, zoomPositionChange ) {
	if( (zoomFactorChange == null || zoomFactorChange == '100%') && zoomPositionChange == null ) {
		ganttVisibleLeft = data.startMin;
		ganttVisibleWidth = data.displayMaxWidth;
		return;
	} 
	if( zoomFactorChange != null && zoomPositionChange == null ) {
		if( ganttVisibleWidth >= data.displayMaxWidth && zoomFactorChange > 1.0 ) {
			return;
		}
		let currentZoomFactor = ganttVisibleWidth / data.displayMaxWidth;
		let newZoomFactor = currentZoomFactor * zoomFactorChange;
		if( !(newZoomFactor > 0) ) {
			return;
		}
		let newWidth = data.displayMaxWidth * newZoomFactor;
		let newLeft = ganttVisibleLeft - (newWidth - ganttVisibleWidth) / 2.0;	
		if( newLeft < data.startMin ) {
			newLeft = data.startMin;
		} else if( newLeft + newWidth > data.displayMax ) {
			newLeft = data.startMin;
		}
		ganttVisibleLeft = newLeft;
		ganttVisibleWidth = newWidth;
		return;
	}
	if( zoomFactorChange == null && zoomPositionChange != null ) {
		let newLeft = ganttVisibleLeft + zoomPositionChange;
		if( newLeft < data.startMin ) {
			newLeft = data.startMin;
		} else if( newLeft + ganttVisibleWidth > data.displayMax ) {
			newLeft = data.displayMax - ganttVisibleWidth;
		}
		ganttVisibleLeft = newLeft;
		return;
	}
}

function zoomY( zoomFactorChange, zoomPositionChange ) {
	if( (zoomFactorChange === null || zoomFactorChange == '100%') && zoomPositionChange === null ) {
		ganttVisibleTop = 0;
		ganttVisibleHeight = data.operations.length;
		return;
	} 
	if( zoomFactorChange !== null && zoomPositionChange === null ) {
		if( ganttVisibleHeight >= data.operations.length && zoomFactorChange > 1.0 ) {
			return;
		}
		let currentZoomFactor = ganttVisibleHeight / data.operations.length;
		let newZoomFactor = currentZoomFactor * zoomFactorChange;
		if( !(newZoomFactor > 0) ) {
			return;
		}
		let newHeight = data.operations.length * newZoomFactor;
		if( newHeight < 1 && zoomFactorChange < 1.0 ) {
			return;
		}
		let newY = ganttVisibleTop - (newHeight - ganttVisibleHeight) / 2.0;	
		if( newY < 0 ) {
			newY = 0;
		} else if( newY + newHeight > data.operations.length ) {
			newY = 0;
		}
		ganttVisibleTop = newY;
		ganttVisibleHeight = newHeight;
		dbg("ganttVisibleTop="+ganttVisibleTop);
		return;
	} 
	if( zoomFactorChange === null && zoomPositionChange !== null ) {
		let newY = ganttVisibleTop + zoomPositionChange;
		if( newY < 0 ) {
			newY = 0;
		} else if( newY + ganttVisibleHeight > data.operations.length ) {
			newY = data.operations.length - ganttVisibleHeight;
		}
		ganttVisibleTop = newY;
		return;
	}
}


function reassignBoundaryValue( knownBoundary, newBoundary, upperBoundary ) {
	if( knownBoundary == -1 ) {
		return newBoundary;
	} 
	if( newBoundary == -1 ) {
		return knownBoundary;
	}
	if( !upperBoundary ) { // Min.
		if( newBoundary < knownBoundary ) {
			return newBoundary;			
		} 
	} else { // Max.
		if( newBoundary > knownBoundary ) {
			return newBoundary;			
		} 		
	}
	return knownBoundary;
}

function getElementPosition(el) {
	let lx=0, ly=0
    for( ; el != null ; ) {
		lx += el.offsetLeft;
		ly += el.offsetTop;
		el = el.offsetParent;    	
    }
    return {x:lx, y:ly};
}

function addOnMouseWheel(elem, handler) {
	if (elem.addEventListener) {
		if ('onwheel' in document) {           // IE9+, FF17+
			elem.addEventListener("wheel", handler);
		} else if ('onmousewheel' in document) {           // óñòàðåâøèé âàðèàíò ñîáûòèÿ
			elem.addEventListener("mousewheel", handler);
		} else {          // 3.5 <= Firefox < 17, áîëåå ñòàðîå ñîáûòèå DOMMouseScroll ïðîïóñòèì
			elem.addEventListener("MozMousePixelScroll", handler);
		}
	} else { // IE8-
		elem.attachEvent("onmousewheel", handler);
	}
}

function zoomXByWheel(e) {
	let delta = e.deltaY || e.detail || e.wheelDelta;
	let zoomFactorChange;
	if( delta > 0 ) {
		zoomFactorChange = zoomFactor;
	} else {
		zoomFactorChange = 1.0/zoomFactor;
	}
	zoomX( zoomFactorChange, null );
	drawGantt();
	drawTimeScale();
	drawGanttHScroll();
}


function onTimeCapturedMouseMove(e) {
	if( !timeCaptured ) {
		return;
	}
	let deltaX = ganttVisibleWidth * (e.clientX - timeCapturedAtX) / ganttSVGWidth;
	zoomX( null, -deltaX );
	drawGantt();
	drawTimeScale();
	drawGanttHScroll();
}


function zoomYByWheel(e) {
	let delta = e.deltaY || e.detail || e.wheelDelta;
	let zoomFactorChange;
	if( delta > 0 ) {
		zoomFactorChange = zoomFactor;
	} else {
		zoomFactorChange = 1.0 / zoomFactor;
	}
	zoomY( zoomFactorChange, null );
	drawGantt();
	drawTableContent();
	drawVerticalScroll();
}


function onGanttCapturedMouseMove(e) {
	if( !ganttCaptured ) {
		return;
	}
	let deltaY = ganttVisibleHeight * (e.clientY - ganttCapturedAtY) / ganttSVGHeight;
	zoomY(null,-deltaY);
	drawGantt();
	drawTableContent();
	drawVerticalScroll();
}


function timeToScreen( timeInSeconds ) {
	return (timeInSeconds - ganttVisibleLeft) * ganttSVGWidth / ganttVisibleWidth; 
}


function screenToTime( screenX ) {
	let xNotScaled = ganttVisibleLeft + screenX * (ganttVisibleWidth - 1) / (ganttSVGWidth-1);
}


function operToScreen( n ) {
	//return ( ( n ) * ganttSVGHeight )/ data.operations.length; 
	return ( n - ganttVisibleTop) * ganttSVGHeight / ganttVisibleHeight; 
} 


function createRect( x, y, width, height, properties ) {
	let rect = document.createElementNS(NS, 'rect');
	if( 'id' in properties ) {
		rect.setAttributeNS(null, 'id', properties.id ); 		
	} 
	rect.setAttributeNS(null, 'x', x ); 
	rect.setAttributeNS(null, 'width', width ); 
	rect.setAttributeNS(null, 'y', y ); 
	rect.setAttributeNS(null, 'height', height );
	if( 'fill' in properties ) {
		rect.setAttributeNS(null, 'fill', properties.fill );
	} 
	if( 'stroke' in properties ) {
		rect.setAttributeNS(null, 'stroke', properties.stroke );
	}
	if( 'strokeWidth' in properties ) {
		rect.setAttributeNS(null, 'stroke-width', properties.strokeWidth );			
	}
	if( 'opacity' in properties ) {
		rect.setAttributeNS(null, 'opacity', properties.opacity );
	} 
	return rect;
}

function createText( textString, x, y, properties ) {
	let text = document.createElementNS(NS, 'text');
	text.setAttributeNS(null,'x', x );
	text.setAttributeNS(null,'y', y );
	if( 'id' in properties ) {
		text.setAttributeNS(null, 'id', properties.id ); 		
	} 
	if( 'fontSize' in properties ) {
		text.setAttributeNS(null,'font-size', properties.fontSize );
	}
	if( 'textAnchor' in properties ) {
		text.setAttributeNS(null,'text-anchor', properties.textAnchor );
	}
	if( 'textLength' in properties ) {
		if( properties.textLength ) {
			text.setAttributeNS(null,'textLength', properties.textLength );			
		}
	}
	if( 'lengthAdjust' in properties ) {
		text.setAttributeNS(null,'lengthAdjust', properties.lengthAdjust );
	}
	if( 'alignmentBaseline' in properties ) {
		text.setAttributeNS(null,'alignment-baseline', properties.alignmentBaseline );
	}
	if( 'preserveAspectRatio' in properties ){
		text.setAttributeNS(null,'preserveAspectRatio', properties.preserveAspectRatio );
	}
	if( 'stroke' in properties ) {
		text.setAttributeNS(null,'stroke', properties.stroke );
	}
	if( 'fill' in properties ) {
		text.setAttributeNS(null,'fill', properties.fill );
	}
	if( 'clipPath' in properties ) {
		text.setAttributeNS(null,'clip-path', properties.clipPath );
	}
	text.appendChild( document.createTextNode( textString ) );
	return text;
}

function createLine( x1, y1, x2, y2, properties ) {
	let line = document.createElementNS(NS, 'line');
	if( 'id' in properties ) {
		line.setAttributeNS(null, 'id', properties.id ); 		
	} 
	if( 'endingArrow' in properties ) {
		if( properties.endingArrow ) {
			line.setAttributeNS(null,'marker-end', 'url(#arrow)');
		}
	}
	line.setAttributeNS(null, 'x1', x1 ); 
	line.setAttributeNS(null, 'y1', y1 ); 
	line.setAttributeNS(null, 'x2', x2 ); 
	line.setAttributeNS(null, 'y2', y2 );
	if( 'fill' in properties ) {
		line.setAttributeNS(null, 'fill', properties.fill );
	} 
	if( 'stroke' in properties ) {
		line.setAttributeNS(null, 'stroke', properties.stroke );
	}
	if( 'strokeWidth' in properties ) {
		line.setAttributeNS(null, 'stroke-width', properties.strokeWidth );			
	}
	if( 'strokeDasharray' in properties ) {
		line.setAttributeNS(null, 'stroke-dasharray', properties.strokeDasharray );					
	}
	if( 'opacity' in properties ) {
		line.setAttributeNS(null, 'opacity', properties.opacity );
	} 
	return line;
}

function createSVG( x, y, width, height, properties ) {
	let svg = document.createElementNS(NS,'svg');
	svg.setAttributeNS(null,'x',x);
	svg.setAttributeNS(null,'y',y);
	svg.setAttributeNS(null,'width', width );
	svg.setAttributeNS(null,'height', height );
	if( 'fill' in properties ) {
		svg.setAttributeNS(null, 'fill', properties.fill);		
	}
	if( 'id' in properties ) {
		svg.setAttributeNS(null, 'id', properties.id);		
	}
	return svg;	
}


function createDefs() {
	let defs = document.createElementNS(NS, 'defs');

    let marker = document.createElementNS(NS, 'marker');
    marker.setAttribute('id', 'arrow');
    marker.setAttribute('viewBox', '0 0 10 10');
    marker.setAttribute('refX', '5');
    marker.setAttribute('refY', '5');
    marker.setAttribute('markerUnits', 'strokeWidth');
    marker.setAttribute('markerWidth', 10 ); //ganttSVGWidth*2 / ganttVisibleWidth );
    marker.setAttribute('markerHeight', 10 ); //ganttSVGWidth*2 / ganttVisibleWidth );
    marker.setAttribute('orient', 'auto');
    let path = document.createElementNS(NS, 'path');
    path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
    marker.appendChild(path);
    defs.appendChild(marker);	

	let gradient = document.createElementNS(NS, 'linearGradient');
	let stops = [ {"color": "#cfcfdf","offset": "0%"}, {"color": "#ffffff","offset": "100%"} ];
	for( let i = 0 ; i < stops.length; i++ ) {
	    let stop = document.createElementNS(NS, 'stop');
	    stop.setAttribute('offset', stops[i].offset);
	    stop.setAttribute('stop-color', stops[i].color);
    	gradient.appendChild(stop);
    }
	gradient.id = 'timeScaleGradient';
	gradient.setAttribute('x1', '0');
	gradient.setAttribute('x2', '1');
	gradient.setAttribute('y1', '0');
	gradient.setAttribute('y2', '0');
	defs.appendChild(gradient);

	let gradient2 = document.createElementNS(NS, 'linearGradient');
	let stops2 = [ {"color": "#f7f7f7","offset": "0%"}, {"color": "#ffffff","offset": "100%"} ];
	for( let i = 0 ; i < stops2.length; i++ ) {
	    let stop = document.createElementNS(NS, 'stop');
	    stop.setAttribute('offset', stops2[i].offset);
	    stop.setAttribute('stop-color', stops2[i].color);
    	gradient2.appendChild(stop);
    }
	gradient2.id = 'ganttGradient';
	gradient2.setAttribute('x1', '0');
	gradient2.setAttribute('x2', '1');
	gradient2.setAttribute('y1', '0');
	gradient2.setAttribute('y2', '0');
	defs.appendChild(gradient2);

    containerSVG.appendChild(defs);
}


function parseDate( dateString ) {
	if( dateString == null ) {
		return null;
	}
    var parsed = dateString.match( /([0-9]+)\.([0-9]+)\.([0-9]+) + ([0-9]+)\:([0-9]+)/ );
    if( parsed.length != 6 ) {
    	return null;
    }
    var date = new Date(parsed[3], parsed[2]-1, parsed[1], parsed[4], parsed[5], 0, 0);
    var timeInSeconds = date.getTime();
    return( { 'date':date, 'timeInSeconds':timeInSeconds/1000 } ); 
}

function dbg(text,append) {
	if(!append) {
		append=false;
	}
	let id = document.getElementById('debug');
	if( !append ) { 
		id.innerText = text; 
	} else {
		id.innerText += text;
	}
}

</script>

</body>

</html
